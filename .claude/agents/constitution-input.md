# Constitution Input for "Evolution of Todo"

## Project Identity

**Project Name:** Evolution of Todo  
**Project Type:** 5-Phase Progressive Hackathon Project  
**Theme:** From CLI to Distributed Cloud-Native AI Systems  
**Development Methodology:** Spec-Driven Development (SDD) using Agentic Dev Stack  
**Role:** Student acts as Product Architect, using AI to build software without writing boilerplate code

## Project Vision

This project simulates the real-world evolution of software. Starting with a simple in-memory CLI application and progressively evolving to a Kubernetes-managed, event-driven, AI-powered distributed system. Each phase builds upon the previous, demonstrating mastery of Spec-Driven Development.

## The Absolute Constraint (NON-NEGOTIABLE)

**NO MANUAL CODE WRITING IS PERMITTED**

This foundational rule defines the entire project:

1. ALL implementation code must be generated by Claude Code through specifications
2. Every feature requires a complete Markdown Spec BEFORE any code generation
3. If Claude Code generates incorrect output, the SPEC must be refined - NEVER edit code manually
4. The review process evaluates: specification quality, prompts used, iteration history, and refinement process
5. Manual code edits disqualify the submission
6. This constraint exists to prove and master Spec-Driven Development as a methodology

There are NO exceptions to this rule.

## Mandatory Development Workflow (Agentic Dev Stack)

Every feature MUST follow this exact sequence without exception:

| Step | Action | Description |
|------|--------|-------------|
| 1 | Write Spec | Create detailed Markdown specification for the feature |
| 2 | Generate Plan | Use /speckit.plan to create technical implementation plan |
| 3 | Break Tasks | Use /speckit.tasks to decompose into actionable items |
| 4 | Implement | Use /speckit.implement via Claude Code to generate code |
| 5 | Validate | Test generated code against spec requirements |
| 6 | Refine | If incorrect, refine SPEC (never code) and repeat from Step 4 |

All steps must be documented and preserved in specs history folder.

## Project Structure (Multi-Phase)

```
evolution-of-todo/
├── .specify/
│   ├── memory/
│   │   └── constitution.md
│   ├── specs/
│   │   ├── phase-1/
│   │   │   └── 001-basic-todo-cli/
│   │   │       ├── spec.md
│   │   │       ├── plan.md
│   │   │       ├── tasks.md
│   │   │       └── research.md
│   │   ├── phase-2/
│   │   │   ├── 001-backend-api/
│   │   │   ├── 002-frontend-app/
│   │   │   └── 003-intermediate-features/
│   │   ├── phase-3/
│   │   │   ├── 001-mcp-tools/
│   │   │   ├── 002-ai-agent/
│   │   │   └── 003-chatbot-ui/
│   │   ├── phase-4/
│   │   │   ├── 001-dockerization/
│   │   │   ├── 002-helm-charts/
│   │   │   └── 003-minikube-deployment/
│   │   └── phase-5/
│   │       ├── 001-kafka-integration/
│   │       ├── 002-dapr-setup/
│   │       └── 003-doks-deployment/
│   └── templates/
│
├── phase-1/
│   ├── src/
│   │   └── todo/
│   │       ├── __init__.py
│   │       ├── main.py
│   │       ├── models.py
│   │       ├── storage.py
│   │       ├── commands.py
│   │       └── display.py
│   ├── tests/
│   │   └── test_todo.py
│   ├── pyproject.toml
│   └── README.md
│
├── phase-2/
│   ├── backend/
│   │   ├── src/
│   │   │   └── todo_api/
│   │   ├── tests/
│   │   ├── pyproject.toml
│   │   └── README.md
│   └── frontend/
│       ├── src/
│       │   └── app/
│       ├── package.json
│       └── README.md
│
├── phase-3/
│   ├── mcp-server/
│   │   └── src/
│   ├── agent/
│   │   └── src/
│   └── chatbot-ui/
│       └── src/
│
├── phase-4/
│   ├── docker/
│   │   ├── Dockerfile.backend
│   │   ├── Dockerfile.frontend
│   │   └── docker-compose.yml
│   ├── helm/
│   │   └── todo-app/
│   └── k8s/
│       └── minikube/
│
├── phase-5/
│   ├── kafka/
│   ├── dapr/
│   └── doks/
│
├── CLAUDE.md
├── README.md
└── .gitignore
```

## Technology Governance by Phase

### Phase I: In-Memory Python Console App

**Required:**

- UV (package manager)
- Python 3.13+
- In-memory storage only (Python data structures)
- `questionary` for interactive CLI prompts
- `rich` for formatted output

**Prohibited:**

- External databases (SQLite, PostgreSQL, Redis, etc.)
- Web frameworks (Flask, FastAPI, Django)
- File persistence (JSON files, pickle, CSV, etc.)
- Third-party task management libraries
- GUI frameworks (Tkinter, PyQt, etc.)

**Allowed Standard Library:**

- `dataclasses` for models
- `datetime` for timestamps
- `uuid` for unique IDs
- `typing` for type hints
- `enum` for enumerations

### Phase II: Full-Stack Web Application (Additive)

**Frontend:**

- Next.js 14+ with App Router exclusively
- TypeScript in strict mode
- shadcn/ui for components
- Tailwind CSS for styling
- Middleware for authentication and routing

**Backend:**

- FastAPI with async endpoints
- SQLModel for ORM
- Pydantic for validation
- Dependency injection pattern

**Database:**

- Neon PostgreSQL (serverless)
- Proper migrations
- Soft deletes

### Phase III: AI-Powered Chatbot (Additive)

**Conversational UI:**

- OpenAI ChatKit

**Agent Framework:**

- OpenAI Agents SDK
- Clear system prompts
- Context management for multi-turn

**Tools:**

- Official MCP SDK
- Atomic, single-purpose tools
- Confirmation for destructive actions

### Phase IV: Local Kubernetes (Additive)

**Containerization:**

- Docker with multi-stage builds
- Minimal base images (distroless preferred)

**Orchestration:**

- Minikube for local K8s
- Helm charts for all deployments
- No raw YAML in production

**AI-Assisted:**

- kubectl-ai
- kagent

**Best Practices:**

- Health checks (liveness, readiness)
- Resource limits and requests
- ConfigMaps and Secrets

### Phase V: Cloud Deployment (Additive)

**Messaging:**

- Apache Kafka for events

**Runtime:**

- Dapr for microservices patterns

**Platform:**

- DigitalOcean DOKS
- Horizontal Pod Autoscaler

## CLI User Experience Principles

### Interaction Philosophy

- **Guided Input Over Free-Form:** Prefer dropdown/selection menus over typing when options are finite
- **Progressive Disclosure:** Show options only when relevant to current context
- **Immediate Feedback:** Confirm every action with clear success/error messages
- **Forgiving Input:** Accept partial matches, case-insensitive commands
- **Graceful Exit:** Allow user to cancel/go back at any prompt (Esc, Ctrl+C)
- **Visual Hierarchy:** Use colors, icons, and formatting to guide user attention

### Input Type Standards

| Context | Input Method |
|---------|--------------|
| Command selection | Arrow-key menu OR typed command (both supported) |
| Yes/No confirmation | Arrow-key selection between options |
| Single selection from finite list | Arrow-key dropdown |
| Task selection | Arrow-key list with task preview |
| Free text (title, description) | Standard text input with validation |

### Visual Feedback Standards

| Type | Format |
|------|--------|
| Success | Green ✓ with descriptive message |
| Error | Red ✗ with helpful guidance and tips |
| Warning | Yellow ⚠ with explanation |
| Info | Blue ℹ for neutral information |
| Tables | Rich formatted tables with borders |

### CLI Library Standards (Phase I)

- `questionary` for interactive prompts (menus, confirmations, selections)
- `rich` for formatted output (tables, colors, panels, status indicators)
- These enhance CLI experience without violating Phase I constraints

## Code Quality Principles

### Python Standards (All Phases)

- Type hints on ALL functions, methods, and variables
- Docstrings for all public functions, classes, and modules
- Use `dataclasses` or `Pydantic` for data models
- PEP 8 naming conventions strictly enforced
- Single responsibility principle for all functions
- Maximum function length: 20 lines
- Maximum file length: 200 lines
- No global mutable state

### TypeScript/Next.js Standards (Phase II+)

- Strict mode enabled - no exceptions
- No `any` type without documented justification
- Server Components by default, Client Components only when necessary
- shadcn/ui components - never reinvent provided components
- Tailwind CSS exclusively - no CSS modules, styled-components, or inline styles

### Error Handling Philosophy

- Graceful handling of ALL invalid input
- Clear, user-friendly error messages with actionable guidance
- Never crash on bad input - always recover gracefully
- Validate all inputs before processing
- Provide helpful tips on how to fix errors

### Code Organization

- Strict separation of concerns
- Models separate from business logic
- Business logic separate from presentation
- No business logic in entry points (main.py, route handlers)

## Testing Philosophy

### Test-First Approach

- Test specifications written BEFORE implementation specs
- Tests define expected behavior that implementation must satisfy
- If tests fail, refine spec - not the test (unless test is wrong)

### Testing Priorities

1. Integration tests (highest priority)
2. Behavioral tests for user flows
3. Contract tests for APIs
4. Unit tests for complex business logic

### Coverage Requirements

- Minimum 80% coverage for business logic
- All user-facing features must have tests
- All error paths must be tested
- Edge cases explicitly tested

### Test Organization

- Tests mirror source structure
- One test file per module
- Descriptive test names that explain behavior

## Documentation Requirements

### README.md (Per Phase)

Each phase folder must have README.md containing:

- Phase overview and objectives
- Prerequisites with version numbers
- Installation instructions (step-by-step)
- Usage examples with expected output
- Feature list with status
- Known limitations

### CLAUDE.md (Root Level)

Single file at project root containing:

- Project context and constraints
- Current phase being developed
- Tech stack summary per phase
- Code standards quick reference
- File organization guidance
- Common commands reference

### Spec Preservation

- ALL specification iterations must be preserved
- Shows refinement process and learning
- Evidence of Spec-Driven Development workflow
- No deletion of failed spec attempts

## Security Principles (Phase II+)

- Environment variables for ALL secrets - never hardcoded
- Authentication required for all data operations
- Input validation on frontend AND backend (defense in depth)
- SQL injection prevention through ORM (no raw queries)
- XSS prevention in frontend
- CORS properly configured for allowed origins only
- Rate limiting on API endpoints
- Secure headers configured (HTTPS, CSP, etc.)

## Performance Principles (Phase II+)

- API response time < 200ms for CRUD operations
- Frontend Time to Interactive < 3 seconds
- Database queries must use indexes for filtered columns
- Pagination required for all list endpoints (max 50 items)
- Lazy loading for non-critical UI components
- No N+1 query problems

## Review Criteria Alignment

All submissions will be evaluated on:

| Criteria | Weight | What's Evaluated |
|----------|--------|------------------|
| Spec Quality | 40% | Clarity, completeness, proper workflow, refinement evidence |
| Generated Code Quality | 30% | Clean, documented, follows standards, well-organized |
| Functionality | 20% | Features work correctly, proper error handling, good UX |
| Process Documentation | 10% | Preserved spec history, clear README/CLAUDE.md, iteration evidence |

## Governance Rules

1. This constitution governs ALL phases of development
2. All principles are mandatory, not suggestions
3. Amendments require documented justification in spec history
4. The no-manual-coding constraint has ZERO exceptions
5. Spec refinement is the ONLY path to correct output
6. Phase-specific technologies are additive - earlier phases remain functional
7. Breaking changes between phases require migration specs
