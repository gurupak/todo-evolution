<!--
Sync Impact Report:
- Version change: (none/initial) → 1.0.0
- Modified principles: Initial creation with 7 core principles
- Added sections: Project Identity, The Absolute Constraint, Mandatory Development Workflow, Project Structure, Technology Governance by Phase (5 phases), CLI User Experience Principles, Code Quality Principles, Testing Philosophy, Documentation Requirements, Security Principles, Performance Principles, Review Criteria Alignment, Governance Rules
- Removed sections: N/A (initial creation)
- Templates requiring updates:
  ✅ plan-template.md - Already aligned with constitution check requirements
  ✅ spec-template.md - Already aligned with user story and requirements structure
  ✅ tasks-template.md - Already aligned with phase-based, testable task structure
- Follow-up TODOs: None
-->

# Evolution of Todo Constitution

## Project Identity

**Project Name:** Evolution of Todo  
**Project Type:** 5-Phase Progressive Hackathon Project  
**Theme:** From CLI to Distributed Cloud-Native AI Systems  
**Development Methodology:** Spec-Driven Development (SDD) using Agentic Dev Stack  
**Role:** Student acts as Product Architect, using AI to build software without writing boilerplate code

## Project Vision

This project simulates the real-world evolution of software. Starting with a simple in-memory CLI application and progressively evolving to a Kubernetes-managed, event-driven, AI-powered distributed system. Each phase builds upon the previous, demonstrating mastery of Spec-Driven Development.

## Core Principles

### I. Spec-Driven Development (NON-NEGOTIABLE)

**THE ABSOLUTE CONSTRAINT: NO MANUAL CODE WRITING IS PERMITTED**

This foundational rule defines the entire project:

1. ALL implementation code MUST be generated by Claude Code through specifications
2. Every feature REQUIRES a complete Markdown Spec BEFORE any code generation
3. If Claude Code generates incorrect output, the SPEC MUST be refined - NEVER edit code manually
4. The review process evaluates: specification quality, prompts used, iteration history, and refinement process
5. Manual code edits disqualify the submission
6. This constraint exists to prove and master Spec-Driven Development as a methodology

**There are NO exceptions to this rule.**

**Rationale:** This project teaches the skill of precise specification writing and iterative refinement - the most valuable skill in AI-assisted development. Manual coding bypasses the learning objective.

### II. Mandatory Development Workflow (Agentic Dev Stack)

Every feature MUST follow this exact sequence without exception:

| Step | Action | Description |
|------|--------|-------------|
| 1 | Write Spec | Create detailed Markdown specification for the feature |
| 2 | Generate Plan | Use /sp.plan to create technical implementation plan |
| 3 | Break Tasks | Use /sp.tasks to decompose into actionable items |
| 4 | Implement | Use /sp.implement via Claude Code to generate code |
| 5 | Validate | Test generated code against spec requirements |
| 6 | Refine | If incorrect, refine SPEC (never code) and repeat from Step 4 |

All steps MUST be documented and preserved in specs history folder.

**Rationale:** Enforcing this workflow ensures systematic, traceable development and creates an audit trail demonstrating mastery of the Spec-Driven Development process.

### III. Test-First Development (NON-NEGOTIABLE)

**Test specifications MUST be written BEFORE implementation specs.**

- Tests define expected behavior that implementation must satisfy
- If tests fail, refine spec - not the test (unless test is demonstrably wrong)
- Minimum 80% coverage for business logic
- All user-facing features MUST have tests
- All error paths MUST be tested
- Edge cases explicitly tested

**Testing Priorities:**
1. Integration tests (highest priority)
2. Behavioral tests for user flows
3. Contract tests for APIs
4. Unit tests for complex business logic

**Rationale:** Test-first development ensures clear acceptance criteria, prevents scope creep, and validates that generated code meets requirements before considering implementation complete.

### IV. Phase-Based Technology Governance

Technologies are **additive** across phases - earlier phases MUST remain functional when new phases are added.

**Phase I: In-Memory Python Console App**
- **Required:** UV (package manager), Python 3.13+, In-memory storage only (Python data structures), `questionary` for interactive CLI prompts, `rich` for formatted output
- **Prohibited:** External databases, Web frameworks, File persistence, Third-party task management libraries, GUI frameworks
- **Allowed Standard Library:** `dataclasses`, `datetime`, `uuid`, `typing`, `enum`

**Phase II: Full-Stack Web Application (Additive)**
- **Frontend:** Next.js 16+ with App Router exclusively, TypeScript strict mode, shadcn/ui, Tailwind CSS
- **Backend:** FastAPI with async endpoints, SQLModel ORM, Pydantic validation, Dependency injection
- **Database:** Neon PostgreSQL (serverless), Proper migrations, Soft deletes

**Phase III: AI-Powered Chatbot (Additive)**
- **Conversational UI:** OpenAI ChatKit
- **Agent Framework:** OpenAI Agents SDK, Clear system prompts, Context management
- **Tools:** Official MCP SDK, Atomic single-purpose tools, Confirmation for destructive actions

**Phase IV: Local Kubernetes (Additive)**
- **Containerization:** Docker multi-stage builds, Minimal base images (distroless preferred)
- **Orchestration:** Minikube for local K8s, Helm charts for all deployments, No raw YAML in production
- **AI-Assisted:** kubectl-ai, kagent
- **Best Practices:** Health checks (liveness, readiness), Resource limits and requests, ConfigMaps and Secrets

**Phase V: Cloud Deployment (Additive)**
- **Messaging:** Apache Kafka for events
- **Runtime:** Dapr for microservices patterns
- **Platform:** DigitalOcean DOKS, Horizontal Pod Autoscaler

**Rationale:** Phased technology introduction mirrors real-world software evolution and prevents overwhelming complexity. Additive approach ensures backward compatibility and demonstrates migration skills.

### V. CLI User Experience Excellence (Phase I Focus)

**Interaction Philosophy:**
- **Guided Input Over Free-Form:** Prefer dropdown/selection menus over typing when options are finite
- **Progressive Disclosure:** Show options only when relevant to current context
- **Immediate Feedback:** Confirm every action with clear success/error messages
- **Forgiving Input:** Accept partial matches, case-insensitive commands
- **Graceful Exit:** Allow user to cancel/go back at any prompt (Esc, Ctrl+C)
- **Visual Hierarchy:** Use colors, icons, and formatting to guide user attention

**Input Type Standards:**

| Context | Input Method |
|---------|--------------|
| Command selection | Arrow-key menu OR typed command (both supported) |
| Yes/No confirmation | Arrow-key selection between options |
| Single selection from finite list | Arrow-key dropdown |
| Task selection | Arrow-key list with task preview |
| Free text (title, description) | Standard text input with validation |

**Visual Feedback Standards:**

| Type | Format |
|------|--------|
| Success | Green ✓ with descriptive message |
| Error | Red ✗ with helpful guidance and tips |
| Warning | Yellow ⚠ with explanation |
| Info | Blue ℹ for neutral information |
| Tables | Rich formatted tables with borders |

**CLI Library Standards:** `questionary` for interactive prompts, `rich` for formatted output

**Rationale:** Professional CLI applications provide excellent user experience through guided interactions, not cryptic command-line flags. This differentiates quality software from quick scripts.

### VI. Code Quality and Organization Standards

**Python Standards (All Phases):**
- Type hints on ALL functions, methods, and variables
- Docstrings for all public functions, classes, and modules
- Use `dataclasses` or `Pydantic` for data models
- PEP 8 naming conventions strictly enforced
- Single responsibility principle for all functions
- Maximum function length: 20 lines
- Maximum file length: 200 lines
- No global mutable state

**TypeScript/Next.js Standards (Phase II+):**
- Strict mode enabled - no exceptions
- No `any` type without documented justification
- Server Components by default, Client Components only when necessary
- shadcn/ui components - never reinvent provided components
- Tailwind CSS exclusively - no CSS modules, styled-components, or inline styles

**Error Handling Philosophy:**
- Graceful handling of ALL invalid input
- Clear, user-friendly error messages with actionable guidance
- Never crash on bad input - always recover gracefully
- Validate all inputs before processing
- Provide helpful tips on how to fix errors

**Code Organization:**
- Strict separation of concerns
- Models separate from business logic
- Business logic separate from presentation
- No business logic in entry points (main.py, route handlers)

**Rationale:** Consistent code quality standards ensure maintainability, readability, and professional-grade output. Generated code should be indistinguishable from expert-written code.

### VII. Documentation and Traceability Requirements

**README.md (Per Phase):**

Each phase folder MUST have README.md containing:
- Phase overview and objectives
- Prerequisites with version numbers
- Installation instructions (step-by-step)
- Usage examples with expected output
- Feature list with status
- Known limitations

**CLAUDE.md (Root Level):**

Single file at project root containing:
- Project context and constraints
- Current phase being developed
- Tech stack summary per phase
- Code standards quick reference
- File organization guidance
- Common commands reference

**Spec Preservation:**
- ALL specification iterations MUST be preserved
- Shows refinement process and learning
- Evidence of Spec-Driven Development workflow
- No deletion of failed spec attempts

**Rationale:** Documentation and traceability are critical evaluation criteria. Preserved spec history demonstrates the iterative refinement process and learning journey.

## Project Structure (Multi-Phase)

```
evolution-of-todo/
├── .specify/
│   ├── memory/
│   │   └── constitution.md
│   ├── specs/
│   │   ├── phase-1/
│   │   │   └── 001-basic-todo-cli/
│   │   │       ├── spec.md
│   │   │       ├── plan.md
│   │   │       ├── tasks.md
│   │   │       └── research.md
│   │   ├── phase-2/
│   │   │   ├── 001-backend-api/
│   │   │   ├── 002-frontend-app/
│   │   │   └── 003-intermediate-features/
│   │   ├── phase-3/
│   │   │   ├── 001-mcp-tools/
│   │   │   ├── 002-ai-agent/
│   │   │   └── 003-chatbot-ui/
│   │   ├── phase-4/
│   │   │   ├── 001-dockerization/
│   │   │   ├── 002-helm-charts/
│   │   │   └── 003-minikube-deployment/
│   │   └── phase-5/
│   │       ├── 001-kafka-integration/
│   │       ├── 002-dapr-setup/
│   │       └── 003-doks-deployment/
│   └── templates/
│
├── phase-1/
│   ├── src/
│   │   └── todo/
│   │       ├── __init__.py
│   │       ├── main.py
│   │       ├── models.py
│   │       ├── storage.py
│   │       ├── commands.py
│   │       └── display.py
│   ├── tests/
│   │   └── test_todo.py
│   ├── pyproject.toml
│   └── README.md
│
├── phase-2/
│   ├── backend/
│   │   ├── src/
│   │   │   └── todo_api/
│   │   ├── tests/
│   │   ├── pyproject.toml
│   │   └── README.md
│   └── frontend/
│       ├── src/
│       │   └── app/
│       ├── package.json
│       └── README.md
│
├── phase-3/
│   ├── mcp-server/
│   │   └── src/
│   ├── agent/
│   │   └── src/
│   └── chatbot-ui/
│       └── src/
│
├── phase-4/
│   ├── docker/
│   │   ├── Dockerfile.backend
│   │   ├── Dockerfile.frontend
│   │   └── docker-compose.yml
│   ├── helm/
│   │   └── todo-app/
│   └── k8s/
│       └── minikube/
│
├── phase-5/
│   ├── kafka/
│   ├── dapr/
│   └── doks/
│
├── CLAUDE.md
├── README.md
└── .gitignore
```

## Security Principles (Phase II+)

- Environment variables for ALL secrets - never hardcoded
- Authentication required for all data operations
- Input validation on frontend AND backend (defense in depth)
- SQL injection prevention through ORM (no raw queries)
- XSS prevention in frontend
- CORS properly configured for allowed origins only
- Rate limiting on API endpoints
- Secure headers configured (HTTPS, CSP, etc.)

## Performance Principles (Phase II+)

- API response time < 200ms for CRUD operations
- Frontend Time to Interactive < 3 seconds
- Database queries MUST use indexes for filtered columns
- Pagination required for all list endpoints (max 50 items)
- Lazy loading for non-critical UI components
- No N+1 query problems

## Review Criteria Alignment

All submissions will be evaluated on:

| Criteria | Weight | What's Evaluated |
|----------|--------|------------------|
| Spec Quality | 40% | Clarity, completeness, proper workflow, refinement evidence |
| Generated Code Quality | 30% | Clean, documented, follows standards, well-organized |
| Functionality | 20% | Features work correctly, proper error handling, good UX |
| Process Documentation | 10% | Preserved spec history, clear README/CLAUDE.md, iteration evidence |

## Governance

1. This constitution governs ALL phases of development
2. All principles are mandatory, not suggestions
3. Amendments require documented justification in spec history
4. The no-manual-coding constraint has ZERO exceptions
5. Spec refinement is the ONLY path to correct output
6. Phase-specific technologies are additive - earlier phases remain functional
7. Breaking changes between phases require migration specs
8. Constitution supersedes all other practices
9. All PRs/reviews MUST verify compliance with constitution principles
10. Complexity MUST be justified - simplicity is the default
11. Use CLAUDE.md for runtime development guidance

**Version**: 1.0.0 | **Ratified**: 2025-12-18 | **Last Amended**: 2025-12-18
